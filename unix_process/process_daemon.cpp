
/**********************	守护进程 deamon **********************/

/* 守护进程（deamon）是生存期长的一种进程。它们常常在系统引导装入时启动
 * 如果需要守护进程随系统 自启动，需要在 /etc/init.d 目录下放置响应的启动脚本，
 * 或者利用 systemctl() 来控制，还有一些其他方法如 supervisor() 等，
 * 可自行网上搜索相关用法），仅在 系统关闭 时 才终止。因为它们 没有 控制终端，
 * 所以说它们是在 后台 运行的，无法和前台的用户交互。
 * daemon 的名称通常为相应的服务后加上一个 d。如 http 服务的 daemon 为 httpd。
 * 使用 shell 命令可以显示系统中已运行的 daemon 程序的信息，包括进程ID、控制终端等内容
-------------------------------------------------------------
从 daemon 的启动和管理方式区分，可以将 daemon 分为两大类：
1.	独立启动守护进程
2.	超级守护进程
-------------------------------------------------------------
独立启动守护进程 stand alone ：
	这种启动后会一直占用内存和系统资源，最大的优点是响应速度快，
	多用于能够随时接受远程请求的服务，如 WWW（httpd）、FTP（vsftpd）等。
超级守护进程 super daemon :
	由一个特殊的 daemon(xinet 进程) 统一 管理。
	这种服务通过一个统一的 xinet 在需要时负责唤醒，当没有远程请求时，
	这些服务都是未启动的，等到有远程请求过来时，xinet 才唤醒相应的服务。
	当远程请求结束后，被唤醒的服务会关闭并释放系统资源。
	super daemon 本身是一个 stand alone 的服务，因为它需要管理后续的其他服务，
	所以它自己本身常驻内存中。
-------------------------------------------------------------
 * shell 查看守护进程命令		$ ps x 		$ ps axj	 $ ps -ef
# 生成名为 example_daemon 的可执行文件
	$ g++ -o example_daemon example_daemon.cpp
	$ ./example_daemon
# 可以看到 example_daemon 进程在后台运行，并且其父进程ID为1
	$ ps -ef | grep example_daemon
	lvnux  17889  1  0  14:37  ?   00:00:00  ./example_daemon	 	*/

#include "unix_process.h"

#include <cstdio>
#include <cstdlib>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h> // POSIX Standard: Primitive System Data Types
#include <unistd.h> // POSIX Standard: Symbolic Constants
#include <iostream>

int process_daemon(); // 守护进程创建步骤；失败返回 -1；成功则父进程退出，子进程继续执行

void daemon() // 守护进程
{
	using namespace std;

	int ret = 0;
	ret = process_daemon(); // 守护进程创建步骤；失败返回 -1；成功则父进程退出，子进程继续执行
	if (ret < 0)
	{
		cerr << "守护进程创建步骤失败 : " << ret << endl;
	}
}


/*	bash shell 	------------------------
		$ g++ test.cpp -o test
		$ ./test myfile.txt youfile.txt one.txt
	c++ 		------------------------
		int main(int argc, char **argv)
----------------------------------------
	c++    		bash shell
	argc	=	${#argv[@]} # 参数个数
	argv[0]	=	myfile.txt 	# 参数 : ./当前文件名
	argv[1]	=	myfile.txt 	# 参数 1
	argv[2]	=	youfile.txt # 参数 2
	argv[3]	=	one.txt 	# 参数 3	  	*/
#if 0
int main(int argc, char **argv)
	{
		daemon();
		return 0;
	}
#endif


/********	守护进程 创建步骤	********/
/*			守护进程 创建步骤
-------------------------------------------------------------
01.	执行一个 fork()之后，父进程退出，子进程继续执行；
	子进程获得一个新的进程ID，但继承了父进程的进程组ID；
	daemon 成为了 init 进程的子进程。
原因：	1.假设 daemon 是从命令行启动的，父进程的终止会被 shell 发现，
	shell 在发现之后会显示出另一个 shell 提示符 并让 子进程继续在后台运行。
		2.子进程被确保不会称为一个进程组组长进程，
		因为它从其父进程那里继承了进程组ID并且拥有了	自己的唯一的进程 ID，
		而这个 进程ID 与继承而来的 进程组ID 是不同的。
-------------------------------------------------------------
	调用 setsid() 成为 守护进程
02. 子进程调用 setsid() 开启一个 新 session 使自己成为 新 session 和 新进程组的 leader。
	并释放 它与控制终端 之间的 所有 关联关系。
	结果就是使子进程: (a)成为新会话的首进程，(b)成为一个新进程组的组长进程，(c)没有控制终端。
	如果 daemon 从来没有打开过终端设备，那么就无需担心 daemon 会重新请求一个控制终端了。
	如果 daemon 后面可能会打开一个终端设备，那么必须要采取措施来确保这个设备不会成为控制终端。
两种方式实现：
	1.在所有可能应用到一个终端设备上的 open() 调用中指定 O_NOCTTY 标记。
	2.在 setsid() 调用之后执行 第二个 fork()，然后再次让 父进程 退出并让 孙子 进程继续执行。
	这样就确保了 子进程 不会称为会话组长，因此根据 System V 中获取终端的规则，
	进程永远不会重新请求一个控制终端。多一个 fork() 调用不会带来任何坏处。
-------------------------------------------------------------
03. chdir ("/") 修改进程的 当前工作目录，通常会改为 根目录 / 。
	这样做是有必要的，因为 daemon 通常会一直运行直至系统关闭为止。
	如果 daemon 的当前工作目录为不包含 / 的文件系统，那么就不能卸载该文件系统。
	或者 daemon 可以将工作目录改为 完成任务时所在的目录 或 在配置文件中定义一个目录(/tmp)，
	只要包含这个目录的文件系统 在运行时不会被卸载 即可，但 能 卸载。
-------------------------------------------------------------
04. 清除进程的 umask 以确保当 daemon 创建 文件 和 目录 时 拥有所需的 文件权限掩码。
	umask() 关闭 daemon 从其 父进程 继承而来的 所有打开着 的 文件描述符。
	设置文件创建 umask(0)，避免创建文件时权限的影响。
	umask(0); // 将当前进程的 文件创建掩码 设置为 0，返回 旧的创建掩码
-------------------------------------------------------------
05.	关闭不需要的打开文件描述符。关闭所有的文件描述符
	可能需要 daemon 保持继承而来的文件描述的打开状态，这一步是可选的或者可变更的。
	因此让 daemon 保持 文件描述符	0（标准输入）、1（标准输出）和 2（标准错误）的
	打开状态 毫无意义，因为它们指向控制终端。
	此外，无法卸载长时间运行的 daemon 打开的文件 所在的文件系统。
	文件描述符是一种有限的资源，通常的做法是 关闭所有 无用的 打开着的 文件描述符。
-------------------------------------------------------------
 06. 终止 daemon 请求
-------------------------------------------------------------
（可选）由于 daemon 失去了 控制终端 并且是在 后台运行，不能和终端交互，无法输出信息，
	也就无法使用 printf 等方法输出信息了。
	可以使用 syslog 机制 或 自己的日志系统 来实现信息的输出，方便程序的调试。
-------------------------------------------------------------
（可选）编写管理 daemon 的 shell 脚本，使用 service 对 daemon 进行管理和监控	*/

#define MAXFILE 65535 // 不需要的文件描述符
volatile sig_atomic_t running_ = 1; // 可以原子修改的整数类型，而不会在操作过程中到达信号
void sigterm_handler(int arg) // 终止请求 处理函数
{
	running_= 0;
}

/*	守护进程 创建步骤	*/
int process_daemon() // 守护进程创建步骤；失败返回 -1；成功则父进程退出，子进程继续执行
{
	using namespace std;

	cout<< "===============================" << endl;
	pid_t pid = getpid(); // 获取 调用进程的进程ID
	cout<< "当前(父)进程 pid : " << pid << endl
		<< "当前(父)进程 PGID: " << getpgrp() << endl
		<< "当前(父)进程 SID : " << getsid( pid ) << endl;

	/**** 创建步骤 第01步 **********************/
	pid = fork(); // 创建 子进程
	if(pid<0) // 负值: 创建子进程失败。
	{
		cout<< "创建子进程失败，pid : " << pid << endl;
		return -1;
	}
	else if (pid==0) // 0 : 当前是 子进程 运行。
	{
		cout<<"当前是子进程运行，child ID : "<< getpid() <<endl;
	}
	else // 正值 : 当前是 父进程 运行。正值 为 子进程 的 进程 ID。
	{
		cout << "当前是父进程运行，parant ID: " << getpid()
			 << ", child ID: " << pid << endl
			 << "父进程退出，子进程继续执行" << endl;
		exit(0); // 父进程退出，子进程继续执行。
	}
	/**** 创建步骤 第02步 **********************/
	pid = setsid(); // 创建一个新会话，并以呼叫进程为领导者。
	if(pid<0) // 负值: 创建失败。
	{
		cout<< "创建新会话失败，pid : " << pid << endl;
		return -2;
	}
	else {
		cout<< "创建新会话，pid : " << pid << endl;
	}
	/**** 创建步骤 第03步 **********************/
	int ret = chdir("../"); // 修改当前进程的工作目录 为 (根)目录 /
	if(ret < 0) // 负值: 创建失败。
	{
		cout << "修改当前进程的工作目录失败，ret : " << ret << endl;
		return -3;
	}
	else {
		cout<< "修改当前进程的工作目录" << endl;
	}
	/**** 创建步骤 第04步 **********************/
	unsigned int ret2 = 0;
	ret2 = umask(0); // 将当前进程的 文件权限掩码 设置为 0，返回 旧的 文件权限掩码
	if(ret2<0) // 负值: 创建失败。
	{
		cout<< "设置文件权限掩码失败，ret : " << ret2 << endl;
		return -4;
	}
	else {
		cout<< "设置文件权限掩码为 0，旧的权限掩码为 " << ret2 << endl;
	}
	/**** 创建步骤 第05步 **********************/
	int fd = -1; // 文件描述符 ; 错误(-1)
	cout << "关闭不需要的文件描述符" << endl;
	cout << "文件描述符 0（标准输入）、1（标准输出）和 2（标准错误）也关闭" << endl;
	for(fd = 0 ; fd < MAXFILE ; fd++) {
		close(fd); // 关闭所有的文件描述符
	}
	/*****************************************/
	char filename[] = "../daemon03.txt"; // 文件名，相对路径(../)
	string buf = "This is a dameon.\n";
	while(running_) {
		fd = open(filename,O_CREAT|O_WRONLY|O_APPEND,0600); // 创建文件 <fcntl.h>
		if( fd < 0 ) {
			perror("open");
			exit(-1);
		}
		write(fd, buf.c_str(), buf.size() );
		close(fd);
		buf.clear() ;
		buf = "This is a dameon.\n";
		usleep(100 * 1000); // 100 毫秒
		/**** 创建步骤 第06步 **********************/
		//	sighandler_t old_handler; // 记录原来的处理方式
		//	old_handler = signal(SIGTERM/* 终止请求 */, sigterm_handler); // <signal.h>
		cout << "守护进程 终止请求" << endl;
		signal(SIGTERM/* 终止请求 */, sigterm_handler/* 终止请求处理函数 */);
		// <signal.h>
		/*****************************************/
	}
	return 0;
}

/*************************************************************************/
/*************************************************************************/
/*************************************************************************/

/* 守护进程 创建步骤：失败返回负值；成功则父进程退出，子进程继续执行 */
int daemon_init()
{
	pid_t pid = getpid(); // 获取 调用进程的进程ID
	int fd = -1; // 文件描述符 ; 错误(-1)
	int retval; // 函数返回值

	/**** 创建步骤 第01步  创建 子进程 **********************/
	pid = fork(); // 创建 子进程
	if(pid<0) return -1; // 负值: 创建子进程失败。
	else if (pid>0)  // 父进程退出，子进程继续执行。
		_exit(0); /* 使用 STATUS 的低8位终止程序执行 */
	/*  pid = 0 : 当前是 子进程 运行。*/

	/**** 创建步骤 第02步 创建新会话 session **********************/
	pid = setsid(); // 创建一个新会话 session，并以呼叫进程为领导者。
	if(pid<0) return -2; // 负值: 创建失败。

	/********** 屏蔽信号 */
	/* 	SIGHUP：终止进程，终端线路挂断，会导致进程退出。
 		本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时,
		通知同一 session 内的各个作业, 这时它们与控制终端不再关联。   */
	if (signal(SIGHUP, SIG_IGN)==SIG_ERR/*Error return*/)return -3;// 负值: 创建失败。

	/********** 再次创建子进程 */
	/* 再次 fork()的目的是确保本守护进程将来即使打开一个终端设备，也不会自动获得控制终端。*/
	pid = fork(); // 创建 子进程
	if(pid<0) return -4; // 负值: 创建子进程失败。
	else if (pid>0)  // 父进程退出，子进程继续执行。
		_exit(0); /* 使用 STATUS 的低8位终止程序执行 */
	/*  pid = 0 : 当前是 子进程 运行。*/

	/********** 生成错误消息 (关闭所有的文件描述符) */
	daemon_proc = 1; /* for err_XXX() functions */

	/**** 创建步骤 第03步 **********************/
	retval = chdir("../"); // 修改当前进程的工作目录 为 (根)目录 /
	if(retval<0) return -5; // 负值: 创建失败。

	/**** 创建步骤 第04步 **********************/
	retval = umask(0); // 将当前进程的 文件权限掩码 设置为 0，返回 旧的 文件权限掩码
	if(retval < 0) return -6; // 负值: 创建失败。

	/**** 创建步骤 第05步 **********************/
	for(int fd_i = 0 ; fd_i < MAXFD ; ++fd_i) close(fd_i); // 关闭所有的文件描述符

	/*********** daemon 守护进程 将 stdin，stdout，stderr 重定向到 /dev/null */
	/* 	即使 关闭所有的文件描述符，有一些普通数据文件句柄将等于 0、1、2。
		以2号句柄为例，某些库函数失败后会向2号句柄输出错误信息，这将破坏原有数据。 */
	// 线程安全的重定向代码
	fd = open("/dev/null", O_RDWR);
	if(fd < 0) exit(-8);
	dup2( fd, 0 );
	dup2( fd, 1 );
	dup2( fd, 2 );
	if ( fd > 2 ) close(fd);
#if 0
	/********** 生成自定义消息 */
	/* 返回一个包含当前目录名称的字符串。如果设置了环境变量"PWD"，并且其值正确，那么将使用该值
	 * /media/zcq/fast-office/ZCQ_cpp_code/网络通信
	 * /ZCQ-UNIX网络编程-套接字/cmake-build-debug        */
	std::string buf = get_current_dir_name();
	/* 生成自定义消息 */
	mymsg(buf);
#endif
#if 0
	/********** 生成日志消息 (自定义？使用日志类库？) */
	/** 生成日志消息 */
	openlog("ZCQ-UNIX网络编程-套接字", LOG_CONS | LOG_PID,
			LOG_LOCAL1 /* 本地策略 /var/log/local1.log */ );
	syslog(LOG_LOCAL1 | LOG_INFO /* /var/log/messages */,
		   "======================================================\n");
//	closelog();
#endif
	return 0;
}

/*************************************************************************/


